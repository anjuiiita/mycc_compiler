%
% LaTeX source file.
%
% To build a pdf, use 'pdflatex developers.tex' on most systems.
%

\documentclass{article}

\title{COM S 540 Project }
\author{Anju Kumari}
\date{}
\usepackage{graphicx}

\begin{document}   
%% %%%%%%%%%%%%%%%%%%%%%%%%%

\maketitle
\section*{}

\subsubsection*{main.c}
There are 5 modes for this project as mentioned below: \\
Valid modes: \\
-0: Version information \\
-1: Part 1 Token Analyzer \\
-2: Part 2 Syntax Analyzer\\
-3: Part 3 Semantic Analyzer \\
-4: Part 4 Intermediate code generator \\
-5: Part 5 Code generation\\

{\it Date Structure:} for part 0, I used fstream library to open and read from file. \\
Only mode 0 is impletemented in this file which gives the information about auther, version and date. \\
For Part 1, flex is used to tokenize the input file. \\
For Part 2, lex and yacc is used for syntax analysis of c file. \\

\subsection*{lexer.l}
This file defines the rules to tokenize the input file.

\subsection*{tokens.h}
This file contains tokens defined in the rules section of flex file\\

\subsection*{lex.cc.c}
This file is autogenerated from lexer.l and tokens.h file \\


\subsection*{parsehelp.cc}
This file contains all the symbol tables and stack machines to store the data\\

\subsection*{parsehelp.h}
This file contains declaration of all the function and symbol tables.\\

\subsection*{grammar.y}
This file is contains the parse tree and production rules to parse c program\\

\subsection*{.o files}
These are auto generated files

\

\subsection*{yacc\_parser.tab.h}
This file is autogenerated from yacc\_parser.y \\

\subsection*{yacc\_parser.tab.c}
This file is autogenerated from yacc\_parser.y \\

\subsection*{Makefile}
This file will produce an executable named "mycc". \\
And also run the developers.tex file and generate developers.pdf file. \\
This also cleans the auto generated files. \\

\subsection*{Readme.md}
This file explain how to build the compiler and run it. \\
{ \bf For part 0}, only mode 0 is implemented which gives information about the author, version and date. \\
{ \bf For Part 1},  mode 1 is implemented where flex is used to tokenize the input file. \\
$\#$include is implemented.
If there is error opening include file, error is genrated and if a cycle if detected then also Error is generated at max depth 256. \\

$\#$define is also implemented, if the defined var is a keyword, it generates approriate erroe message and also checks the length of replacement text and appropriate error is generated. \\

$\#$ifdef, ifndef, else, endif mismatched detection is implemented.
And if indentifier if not defined,  error is generated.

{ \bf For part 2},  mode 2 is implemented which uses lex and yacc to tokenize the input file and build parse tree. To run mode 2 please run below command.

mycc -2 $\langle input file\rangle$

Part 1 and 0 are working as before.

In part 2, it checks only the input file syntax.  \\
Production rules are defined to check the syntax \\
EXTRA : variable initialization, CONSTANTS, STRUCT, struct member selection are defined. \\

{ \bf For part 3},  mode 3 is implemented which uses lex and yacc to tokenize the input file and build parse tree. \\
Did semantic analysis using symbol tables. \\

To run mode 3 please run below command. \\

mycc -3  $\langle input file\rangle$ \\

Part 0, 1 and 2 are working as before. \\

In part 3, it does only the input file semantic analysis. \\
Production rules are defined to check the syntax \\
EXTRA :  initialization, const, user-defined structs, struct member selection are defined. \\

{ \bf For part 4},  mode 4 is implemented which stack machine to generate java bytecode using stack machin code.

To run mode 4 please run below command.

mycc -4  $\langle input file\rangle$ \\

Part 0, 1, 2 and 3 are working as before.

In part 4, it generated the intermediate code for given input program
Arrays, Expressions, Function calls, user functions and always present output, operators
special methos clinit are implemented.
EXTRA :  initialization, handling global variables.

{ \bf  For Part 5}, mode 5 is implemented which uses marker in production rules to create labels for control flow. 

To run mode 5 please run below command.

mycc -5 $\langle input file\rangle$ \\

Part 0, 1, 2, 3 and 4 are working as before.

In part 5,  Code generation is implemented for given input program

Control flow for if, if else, while,boolean , comparison and or not ifne is implemented 



\end{document}